/*

电子数字在生活中很常见，而许多的电子数字是由LED数码管制作而成。数字LED数码管一般由7个发光二极管封装在一起，组成'8'字型，引线在内部连接完成。

如下图所示，我们可以对每个发光管进行编码从1到7。而数字0到数字9可以由这七根发光管的亮暗来表示。

digit8.jpg

对LED数码管的二极管进行编码

digit.jpg

用LED数码管表示数字0-9

假设我们现在有从左到右排列好的K个LED数码管，并且我们已知每个数码管当前有哪些编号的二极管是亮着的，另外剩余的二极管由于某些原因，我们并不清楚它们的亮暗情况。
由于已经有部分二极管是确定亮着的，所以每个LED数码管能表示的数字范围会有所缩小，譬如假设1号二极管已经确定是亮着的状态，那么这个LED数码管就不能表示数字1和4。

我们想知道的是，给定一个数N，在这K个LED数码管的当前亮暗的状态下，所有可能表示的数中，比N小的数有多少个。

注意，前导0是必须的，假设有4个数码管的话，'0000'表示0，'0123'表示123，即每个数的表示方法唯一。

输入
每个输入数据包含多个测试点。

第一行为测试点的个数 S ≤ 100。之后是 S 个测试点的数据。测试点之间无空行。

每个测试点的第一行为 K(1 ≤ K ≤ 5)和N(0 ≤ N ≤ 109)。之后是K行，每行表示对应数码管已点亮的二极管的情况。每行至少包含一个数字，表示对应点亮的二极管的编号，
即每个数码管至少有一根二极管是点亮的。二极管编号的范围保证在1到7之间，且每行无重复编号。


注意表示数码管点亮情况的每行数字之间以及行首行末之间可能存在冗余空格，每行的字符总长度不超过100。

输出
对于每个测试点，对应的结果输出一行，表示这K个数码管在当前状态下，所有可能表示的数中，比N小的数有多少个。

样例解释
第一个样例中，只有'020', '026', '028'符合要求。

第三个样例中，只有'000'符合要求。

样例输入
3
3 50
3  1
1  4  5
1   5  6 7
4 100
1 2 3
4   5
6
7
1 1
7
样例输出
3
0
1

*/
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

//#define ONE		0x0100100
//#define TWO		0x1011101
//#define THREE	0x1101101
//#define FOUR    0x0101110
//#define FIVE	0x1101011
//#define SIX		0x1111011
//#define SEVEN	0x0100101
//#define EIGHT	0x1111111
//#define NINE	0x1101111
//#define ZERO	0x1110111\


int K, N, S;
int ans = 0;
bool led[6][10]; //代表K个数字中，每个能拼成的哪些数字， 0 代表不能拼成，1代表能拼成
bool old[10][8] = {
	{ 0, 1, 1, 1, 0, 1, 1, 1 },
	{ 0, 0, 0, 1, 0, 0, 1, 0 },
	{ 0, 1, 0, 1, 1, 1, 0, 1 },
	{ 0, 1, 0, 1, 1, 0, 1, 1 },
	{ 0, 0, 1, 1, 1, 0, 1, 0 },

	{ 0, 1, 1, 0, 1, 0, 1, 1 },
	{ 0, 1, 1, 0, 1, 1, 1, 1 },
	{ 0, 1, 0, 1, 0, 0, 1, 0 },
	{ 0, 1, 1, 1, 1, 1, 1, 1 },
	{ 0, 1, 1, 1, 1, 0, 1, 1 }
};

void dfs(int step, int value)
{
	if (step == K)
	{
		if (value < N) ans++;
	}
	else
	{
		for (int i = 0; i < 10; ++i)
		{
			int temp = value;

			if (led[step][i])
			{
				temp *= 10;
				temp += i;

				dfs(step + 1, temp);
			}
		}
	}
}

int main()
{
	string s;
	cin >> S;
	while (S--)
	{
		cin >> K >> N;
		getchar(); //这个的作用非常大，读取了回车。

		ans = 0;
		for (int i = 0; i< K; ++i){
			for (int j = 0; j < 10; ++j)
				led[i][j] = true;

			getline(cin, s);
			istringstream str(s);
			int c;
			while (str >> c)
			{
				for (int j = 0; j < 10; ++j)
				{
					if (old[j][c] && led[i][j])
					{
						led[i][j] = true;
					}
					else
					{
						led[i][j] = false;
					}
				}
			}
		}
		dfs(0, 0);
		cout << ans << endl;
	}

	return 0;
}